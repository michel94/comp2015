
\documentclass[12pt]{article}
\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{fullpage}
\usepackage{longtable}

\begin{document}

\begin{titlepage}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} % Defines a new command for the horizontal lines, change thickness here

\center
 
%----------------------------------------------------------------------------------------
%	HEADING SECTIONS
%----------------------------------------------------------------------------------------

\textsc{\LARGE University of Coimbra}\\[1.5cm] % Name of your university/college
\textsc{\Large Bachelor in Informatics Engineering}\\[0.5cm] % Major heading such as course name
\textsc{\large Compilers Course}\\[0.5cm] % Minor heading such as course title

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\HRule \\[0.4cm]
{ \huge \bfseries Compilers Project Report}\\[0.4cm] % Title of your document
\HRule \\[1.5cm]
 
%----------------------------------------------------------------------------------------
%	AUTHOR SECTION
%----------------------------------------------------------------------------------------

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Authors:}\\
Ricardo Gomes \\
Miguel Duarte
\end{flushleft}
\end{minipage}
~
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\end{flushright}
\end{minipage}\\[2cm]

%----------------------------------------------------------------------------------------
%	DATE SECTION
%----------------------------------------------------------------------------------------

{\large \today}\\[2cm] % Date, change the \today to a set date if you want to be precise

%----------------------------------------------------------------------------------------
%	LOGO SECTION
%----------------------------------------------------------------------------------------

\includegraphics [width=9cm]{logo.jpg}\\[1cm] % Include a department/university logo - this will require the graphicx package
 
%----------------------------------------------------------------------------------------

\vfill % Fill the rest of the page with whitespace

\end{titlepage}


\section{Introduction}

This report concerns the implementation of a mili-pascal compiler and is a project for the Compilers course.

\subsection{Code organization}

Multiple code files were used for this project. mpacompiler.l has the lex code, for lexical analysis. mpacompiler.y has the yacc code and some code for parsing tree generation, used when yyparse runs. parsing.h has basically the code for semantic analysis. Includes parsing of the generated tree and creation of symbol tables.\\
The other two files have some support code. types.h define all data types, including the node struct, and provide functions for conversion between types, for example string to type, type to string, type to llvm type, etc. hashtable.h implements a hashtable, used to implement the symbol tables used.\\

\newpage

\section{Lexical Analysis}

Lexical analysis was really simple and few lines of code were written for this phase. Next we refer the more important things that we did.\\

\subsection{Options}

We enabled ``caseless" and ``yylineno". Caseless is used to match both lower case and upper case in the regular expressions, because pascal is a case insensitive language. Yylineno is used to tell lex to update the yylineno variable with current line of the token read.

\subsection{YY\_USER\_ACTION}

We defined a YY\_USER\_ACTION, that runs code for each token read. It's used to increment the current column variable and to update yylloc and yyval lex/yacc shared variables. The default yylloc struct was used, with the properties first\_line and first\_column. We found this a easy way to access the column and the line of each token, which is useful in later phases, for example in semantic analysis. We also store the string of the token in the yyval.str.\\

\subsection{Basic Tokens}

The tokens are parsed in a straight forward way. If the regular expression matches a token, returns the correspondent token id, generated by yacc.\\ For the operators made only by one character, we use the same regular expression and return the first character read.\\

\subsection{Comment Start States}

The case of comments parsing is a bit more complicated. Because of that we used a start state that works similarly to a state a machine.\\
Basically we define different states and when something is matched we jump to other states or we do some updates like setting column number.\\
For Pascal comments when ``\{" or ``(*" is parsed we define a begin state and until we read ``\}" or ``*)" we do nothing but control column number.\\

\subsection{Errors}

Unterminated string error is caught by reading a specific regular expression right after the terminated string r.e. So, if the string is not read as terminated, it will be read as unterminated, at end of the line, because the \textbackslash n character is not a valid one.\\
Unterminated comment error is caugnt when eof is read inside the comment start state.\\
Error handling is parsed by printing the invalid character and the respective column and line (using our column variable and yylineno).\\

\newpage

\section{Syntax Analysis}

\subsection{Token Types}

We define two types of yacc token: str (char*) and node (struct node*). \\
The tokens id, string, reallit and intlit where declared with type str, the reserved names without type and the operation symbols with type str (to be used later in semantic errors).\\

\subsection{Tree Node generation}

The nodes of the parsing tree contain multiple variables. ``value" and ``value2" contain the token string for terminal nodes, in lower case and as read in the file, respectively.\\
The variable ``op" and ``n\_op" are used to store child nodes and number of child nodes, respectively. ``to\_use" is used to identify a node as a list-node i.e., as a superfluous one, to be removed in the bottom-up parsing.

\subsection{Tree generation}

Parsing is made using two functions: ``make\_node" and ``terminal". \\
``terminal" generates the node for the terminal symbols (id, intlit, realit and string). Obviously, those nodes are non-superfluous. Also, the value of the node is stored in lower case to be used later in id lookups.\\
The ``make\_node" function creates each other type of node, receiving the node type and the ``to\_use" variable in its arguments. The node arguments are parsed and add to this node children. If any of those children is a list-node, those child's children (grandchildren of the new node) are appended to the new node children.

\subsection{Grammar Considerations}

After finising the translation of the given grammar in the project report from ebnf to bnf and write it to yacc we got some shift/reduce conflicts as expected, since the grammar is ambiguous. The problems were in the if/else and in the majority of the expressions. \\
The expressions were fixed by replacing their productions with the ones from the grammar provided by ISO-7185:1990 since this grammar is unambiguous. We used that grammar with some modifications, to make it left recursive and implementable by yacc. We needed those productions to be left recursive because we will later use top-down parsing and the left expressions will have greater priority, i.e., will be deeper in the parsing tree. \\
The famous dangling else conflict was solved by giving right precedence to both `then' and `else', but giving greater precedence to the else token. \\
So, reducing a ``if then else" expression has greater precedence than reducing a ``if then" one. \\

\subsection{Final Grammar}

\begin{verbatim}
Prog -> ProgHeading ; ProgBlock . 				
ProgHeading -> PROGRAM IdProd ( OUTPUT ) 			
ProgBlock -> VarPart FuncPart StatPart 				
VarPart -> VAR VarDeclaration ; VarDeclarationList 	
      | empty 				

VarDeclarationList -> VarDeclarationList VarDeclaration
      | empty				

VarDeclaration -> IdList : IdProd					
IdList -> IdProd IdListLoop	
IdListLoop -> IdListLoop , IdProd					
      | empty				

IdProd -> ID 					

FuncPart -> FuncDeclarationList 
FuncDeclarationList -> FuncDeclarationList FuncDeclaration 
      | empty				
FuncDeclaration -> FuncHeading ; FORWARD			
      | FuncIdent ; FuncBlock 
      | FuncHeading ; FuncBlock

FuncHeading -> FUNCTION IdProd NullFormalParam : IdProd 
FuncIdent -> FUNCTION IdProd	
FuncBlock -> VarPart StatPart	

NullFormalParam -> FuncParams 
      | empty				

FuncParams -> ( FormalParamsList ) 				
FormalParamsList -> FormalParamsList ; FormalParams 
      | FormalParams			

FormalParams -> VarParams 	
      | Params 		

VarParams -> VAR IdList : IdProd 					
Params -> IdList : IdProd 	

StatPart -> CompStat 			
StatList -> Stat StatListLoop	
StatListLoop -> StatListLoop ; Stat 				
      | empty				

CompStat -> BEG StatList END	 
Stat -> CompStat				
      | IF Expr THEN Stat 	
      | IF Expr THEN Stat ELSE Stat 					
      | WHILE Expr DO Stat 	
      | REPEAT StatList UNTIL Expr 					
      | VAL ( PARAMSTR ( Expr ) , IdProd )	
      | WRITELN WriteList  	
      | WRITELN 				
      | IdProd ASSIGN Expr 	
      | empty				

WriteList -> ( ExprString ExprStringList ) 		
ExprStringList -> ExprStringList , ExprString 		
      | empty				

ExprString -> Expr 			
      | STRING 				

Expr -> SimpleExpr < SimpleExpr 
      | SimpleExpr > SimpleExpr
      | SimpleExpr = SimpleExpr 
      | SimpleExpr NEQ SimpleExpr 		
      | SimpleExpr LEQ SimpleExpr 	
      | SimpleExpr GEQ SimpleExpr 					
      | SimpleExpr 			


SimpleExpr -> AddOp			
      | Term 					

AddOp -> SimpleExpr + Term	
      | SimpleExpr - Term	
      | SimpleExpr OR Term 	
      | + Term	
      | - Term	

Term -> Factor	
      | Term * Factor		
      | Term / Factor  	
      | Term DIV Factor  		
      | Term MOD Factor  		
      | Term AND Factor  		

Factor ->	( Expr ) 		
      | INTLIT 				
      | REALLIT 				
      | ID 					
      | NOT Factor 			
      | IdProd ParamList 		


ParamList -> ( Expr ExprList )					
ExprList -> ExprList , Expr 
      | empty				
\end{verbatim}

\newpage

\section{Semantic Analysis}

\subsection{Top-Down Parsing}

The parsing is done in a top-down way. The ``parse\_tree" function parses each node recursively. It starts by identifying the node type and calling the specific function to parse that node. Each of those specific functions will then parse the children nodes and if no error is found in any of them, parses the argument node itself. The parsing of each children node is done by calling the ``parse\_tree" function for each of them. That way, identifying the type of node is done only in one function, allowing a cleaner code.\\

\subsection{Internal format of Symbol Table}

The hashtable was the chosen data structure to represent the internal format of the symbol table. \\
We picked this structure because of it's efficiency and because it's the most common implementation in todays compilers. This critical structure has two main functions. The first one, store, is used to place a symbol in the hash table. The other function, fetch, is used to lookup the hash table for a symbol. This two functions use in common another function, hash\_fnv1a, that is responsible to produce a value from a string, value that is later used as a position in the table or not if there are collisions. \\
By maintaining an array of pointers that is updated when a store is called, and by pointing it to the new symbol, we guarantee order in the found sequence symbols. \\
The symbols of the hash table are characterized by a name, a type to distinguish for example a number from integer to real, a flag which identifies symbols as parameters or constants, as well as a value which corresponds to the parsed token, for hash table store and lookup and error printing purposes. \\

\subsection{Ids}

We keep the outer symbol table, the program symbol table and a symbol table for each function. \\
If an id is used inside an expression, we search the function scope (if we are inside a function), the program scope and the outer scope, until we find this id. If it's found, we get its type and store it in the node, to be used by the parent node. In the special case that the id found is a function without arguments, then we convert the id node into a call node. \\
If the id is declared as a function argument or declared in the beginning of the program or in the beginning of a function, they are added to the symbol table in the correspondent scope. In the function arguments, we also store the specific flag (``varparam" or ``param").

\subsection{Expressions}

The expressions are parsed accordingly to its type. Some of them use the same parse function. Those groups of expressions are: Add, Sub and Mul (parse\_op function); Boolean operations (Lt, Gt, Eq, etc) (parse\_eq function); Or and And (parse\_bool function); Unary operations (parse\_unary function); RealDiv; Div and Mod.\\
Another common thing to expressions parsing is that all of them store in the respective node the result type after parsing the two children (in the variable ``op\_type"). For example, Add and the similar group of operations set the result type to integer if both parameters returned are integers. If they are both real or one of them is integer and the other is integer, then the result is real. Otherwise, there is an error that will be reported. The parsing functions will return 1 until we reach the top node of the program.\\
To store variable types, we use a enum type\_t, with INTEGER\_T, REAL\_T, etc.\\

\subsection{Functions}
There are three types of nodes that need to be parsed for semantic analysis. Those are FuncDef, FuncDef2 and FuncDecl. Inside FuncDef and FuncDecl we need to do some checks before creating a table. If it already exists in the PROGRAM symbol table we generate an error. After that we need to check its return type. If it's invalid, we generate an error too. \\
FuncDef2 is used to define a function previously declared as forward. Within FuncDef2 there are two cases that need to be considered for error generation. We must detect if we are trying to define a function with FuncDef2 that hasn't been declared yet, or if we're trying to define a function with FuncDef2 that as already been defined. In both cases we generate the right error. \\

\subsection{Statements}
The statements are parsed considering their operands. Statement operands are previously parsed so we can check their types to raise an error when an incompatibility is found.\\

\subsection{Errors}

\begin{longtable} {|p{3.0cm} | p{8cm} | p{4.0cm}|} 
 \textbf{Node Type} 	& \textbf{Problem} & \textbf{Error Message} \\ \hline
	Add, Mul, Sub 		& One of the operands is boolean or has undefined type (\_type\_) & Operator cannot be applied to types \\ \hline
	Or, And 			& One of the operands isn't boolean & Operator cannot be applied to types \\ \hline
	Lt, Gt, Leq, Geq, Eq, Neq &		One of the operands has undefined type (\_type\_) or operands are from incompatible types & Operator cannot be applied to types \\ \hline
	Minus, Plus 		& Operand isn't real or integer & Operator cannot be applied to type \\ \hline
	Not 				& Operand isn't boolean & Operator cannot be applied to type \\ \hline
	Div, Mod 			& One of the operands isn't integer & Operator cannot be applied to types \\ \hline
	RealDiv				& One of the operands is boolean or has undefined type (\_type\_) & Operator cannot be applied to types \\ \hline
	If, While, Repeat Until & Operand isn't boolean & Incompatible type in statement got, expected \\ \hline
	ValParam 			& One of the operands isn't integer & Incompatible type in statement got, expected \\ \hline
	\multirow{3}{*}{Assign} & Operands are from incompatible types & Incompatible type in assignment to got, expected \\ \cline{2-3}
							& Left operand has undefined type(\_type\_) or is a constant & Variable identifier expected \\ \cline{2-3}
							& Variable not previously declared i.e not present in any scope & Symbol not defined \\ \hline
	Writeln 			& One of the operands has undefined type (\_type\_) & Cannot write values of type \\ \hline
	\multirow{3}{*}{Call} 	& Different number of arguments in call compared to the ones of the function declaration & Wrong number of arguments in call to function got, expected \\ \cline{2-3}
	 					& Arguments have incompatible types (conversion from integer to non integer, boolean to non boolean and real to boolean are invalid) & Incompatible type for argument in call to function  \\ \cline{2-3}
						& Constants or id's that are passed to var arguments and argument types that don't match & Variable identifier expected  \\ \hline
	Id 					& Id is not present in the current scope, or program and outer scopes by this order & Symbol not defined  \\ \hline
	FuncDef			& Invalid return type & Type identifier expected \\ \hline
	\multirow{2}{*}{FuncDef2} & Function has not been declared before & Function identifier expected \\ \cline{2-3}
					& Function has already been defined & Symbol already defined \\ \hline

\end{longtable}

\newpage

\subsection{Expression types}

In the next table, we show the type of the result of each expression, considering valid types of operands. \\

\begin{tabularx} {\textwidth} {|X|X|X|} 
 \textbf{Operation Type} 	& \textbf{Operands} & \textbf{Expression type} \\ \hline
	\multirow{2}{*}{Add, Mul, Sub} 	& Integer & Integer \\ \cline{2-3}
									& At least one of them is real & Real \\ \hline
	\multirow{3}{*}{Lt, Gt, Leq, Geq, Eq, Neq} 	& Integer & Integer \\ \cline{2-3}
												& Boolean & Boolean \\ \cline{2-3}
												& At least one of them is Real & Real \\ \hline
	\multirow{2}{*}{Plus, Minus} 				& Integer & Integer \\ \cline{2-3}
												& Real & Real \\ \hline
	Not & Boolean & Boolean \\ \hline
	Or, And & Boolean & Boolean \\ \hline
	Div, Mod & Integer & Integer \\ \hline
	RealDiv & Real & Real \\ \hline
	

\end{tabularx}

\newpage

\section{Code generation}

\subsection{Parsing}
Code generation is done by traversing of the parse tree, using a recursive function, in a top-down way. \\
The ``code\_gen" function parses each node recursively. It starts by identifying the node type and calling the specific function to parse that node. Each of those specific functions will then generate code for the children nodes. The parent will only generate code after its children have generated their one.

\subsection{Ids}
Variable Ids can be used in two ways: to declare variables or to fetch values of existing ones. \\
To declare variables (``VarDecl"), we simply have to consider the current context and use ``alloca" for local ones, inside functions, and ``global", for program ones. \\
To fetch values of variables, we have to find the llvm variable to fetch, according to the name and the context. We find out if the variable is global or local and, according to it, we write the specific prefix.

\subsection{Expressions}

The parse tree can be easily translated to 3 address code or, in this case, llvm-ir. \\
Code for expressions is generated recursively, using the ``code\_gen" function. That function proceeds in the following way:
\begin{itemize}
	\item calls the ``code\_gen" function for the left operand;
	\item calls the ``code\_gen" function for the right operand;
	\item obtains the register index in which the value of the two operands is stored;
	\item performs any casting needed on those operands, updating the registers of the operands to use, calling the ``real\_cast" function;
	\item generates the operation code, using those registers and a new one.
\end{itemize}

To keep record of the next register index to use, a global counter is incremented. \\
To generate the proper expression, we use the function ``op2llvm", that receives the expression name and the type of return, as is stored in the parse tree, and returns the exact llvm code to be used. The return type is enough to generate the llvm operator.\\

\subsection{Functions}

Functions are generated for the nodes ``Funcdef" and ``Funcdef2" of the parse tree. ``Funcdecl" nodes can be ignored, as we explain later. \\
For ``Funcdef"/``Funcdef2" we generate llvm functions with the same name plus ``\_f" in the end, to avoid name conflicts. The arguments types are simple: integer is i32, real is double and boolean is i1. Varparams are passed as pointers, and can be used inside the function as variables. So, we simply add an ``\_" in the beginning in the argument name. Params are passed only with value. So we store them temporarily in a variable with ``\_\_" in the beginning and, after the function header, we allocate those variables locally and store these values in them. \\
Also, we set the current scope to the one corresponding to the current function, such that in the recursive parsing, we know where to fetch the ids of the variables.

\subsection{Calls}

Calls follow what was specified in the functions. In the case of the ``Param", we simply parse the expression and get the register to be passed as parameter. If needed, we cast the value to real. For ``VarParam", we fetch the variable to be passed, given its name, and pass it to the function too.

\subsection{Statements}

Generating code for statements is a bit more complex. Most statements, like if, while and repeat need to be generated using labels. This is important so we can later use an expression to jump to those labels, for example to simulate loops. \\ 
Besides, register count we also need a label count to keep track of the labels. This is also important because when we want to request a new label we just need to increment the counter and store it's value. For if statement we use 3 labels, a then label, a else label and a return label. For while we also use 3 labels. Those are compare, inside and return. For repeat until we only need two because the comparison in the until part can be done in the inside label. \\
The statement ``valparam str" can be easily generated because it's static. We just need to request a new register and call a llvm valparam function, implemented by us, to get the console argument. The same technique is done for ``paramcount". This function is inserted in the end of the generated code. If the user defines a paramcount function, we called that one. Otherwise, we call our one paramcount function.\\
To generate code for the ``writeln" statement, we use the printf function. To print strings, we have to keep them in a list, and in the end, we define them as global (because parsing order doesn't matter in llvm). To print integers and reals, we call printf with a specific argument string, and the register to print. To print booleans, we implemented our own function, that evaluates the boolean value and chooses which one of two strings will print. \\


\end{document}